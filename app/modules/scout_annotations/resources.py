# -*- coding: utf-8 -*-
# pylint: disable=bad-continuation
"""
RESTful API Annotations resources
--------------------------
"""

import logging
from http import HTTPStatus

from flask import request

import app.extensions.logging as AuditLog
from app.extensions import db
from app.extensions.api import Namespace, abort
from app.modules.annotations.models import Annotation
from app.modules.users import permissions
from app.modules.users.permissions.types import AccessOperation
from app.utils import HoustonException
from flask_restx_patched import Resource

from . import parameters, schemas
from .models import ScoutAnnotation

log = logging.getLogger(__name__)  # pylint: disable=invalid-name
api = Namespace('annotations', description='Annotations')  # pylint: disable=invalid-name


@api.route('/')
@api.login_required(oauth_scopes=['annotations:read'])
class Annotations(Resource):
    """
    Manipulations with Annotations.
    """

    @api.permission_required(
        permissions.ModuleAccessPermission,
        kwargs_on_request=lambda kwargs: {
            'module': Annotation,
            'action': AccessOperation.READ,
        },
    )
    @api.response(schemas.BaseAnnotationSchema(many=True))
    @api.paginate()
    def get(self, args):
        """
        List of Annotation.
        """
        return Annotation.query_search(args=args)

    @api.permission_required(
        permissions.ModuleAccessPermission,
        kwargs_on_request=lambda kwargs: {
            'module': Annotation,
            'action': AccessOperation.WRITE,
        },
    )
    @api.login_required(oauth_scopes=['annotations:write'])
    @api.parameters(parameters.CreateAnnotationParameters())
    @api.response(schemas.DetailedAnnotationSchema())
    @api.response(code=HTTPStatus.BAD_REQUEST)
    @api.response(code=HTTPStatus.CONFLICT)
    def post(self, args):
        """
        Create a new instance of Annotation.
        """
        from app.extensions.elapsed_time import ElapsedTime
        from app.modules.assets.models import Asset
        from app.modules.missions.models import MissionTask

        timer = ElapsedTime()

        if 'asset_guid' not in args:
            abort(code=HTTPStatus.BAD_REQUEST, message='Must provide an asset_guid')

        asset_guid = args.get('asset_guid', None)
        asset = Asset.query.get(asset_guid)
        if not asset:
            abort(code=HTTPStatus.BAD_REQUEST, message='asset_guid not found')
        args['asset_guid'] = asset_guid

        task_guid = args.get('task_guid', None)

        if not task_guid:
            abort(code=HTTPStatus.BAD_REQUEST, message='Must provide a task_guid')
        task = MissionTask.query.get(task_guid)
        if not task:
            abort(code=HTTPStatus.BAD_REQUEST, message='task_guid not found')
        args['task_guid'] = task_guid

        context = api.commit_or_abort(
            db.session, default_error_message='Failed to create a new Annotation'
        )
        with context:
            args['autogenerated'] = False
            annotation = Annotation(**args)
            AuditLog.user_create_object(log, annotation, duration=timer.elapsed())
            db.session.add(annotation)
        try:
            # needs to be after the add to ensure asset is valid
            annotation.sync_with_sage()
        except HoustonException as ex:
            abort(400, ex.message)
        return annotation


@api.route('/search')
@api.login_required(oauth_scopes=['annotations:read'])
class AnnotationElasticsearch(Resource):
    @api.permission_required(
        permissions.ModuleAccessPermission,
        kwargs_on_request=lambda kwargs: {
            'module': Annotation,
            'action': AccessOperation.READ,
        },
    )
    @api.response(schemas.BaseAnnotationSchema(many=True))
    @api.paginate()
    def get(self, args):
        search = {}
        args['total'] = True
        return Annotation.elasticsearch(search, **args)

    @api.permission_required(
        permissions.ModuleAccessPermission,
        kwargs_on_request=lambda kwargs: {
            'module': Annotation,
            'action': AccessOperation.READ,
        },
    )
    @api.response(schemas.BaseAnnotationSchema(many=True))
    @api.paginate()
    def post(self, args):
        search = request.get_json()
        args['total'] = True
        return Annotation.elasticsearch(search, **args)


@api.route('/<uuid:annotation_guid>')
@api.response(
    code=HTTPStatus.NOT_FOUND,
    description='Annotation not found.',
)
@api.resolve_object_by_model(ScoutAnnotation, 'annotation')
class AnnotationByID(Resource):
    """
    Manipulations with a specific Annotation.
    """

    @api.permission_required(
        permissions.ObjectAccessPermission,
        kwargs_on_request=lambda kwargs: {
            'obj': kwargs['annotation'],
            'action': AccessOperation.READ,
        },
    )
    @api.response(schemas.DetailedAnnotationSchema())
    def get(self, annotation):
        """
        Get Annotation details by ID.
        """
        return annotation

    @api.permission_required(
        permissions.ObjectAccessPermission,
        kwargs_on_request=lambda kwargs: {
            'obj': kwargs['annotation'],
            'action': AccessOperation.WRITE,
        },
    )
    @api.login_required(oauth_scopes=['annotations:write'])
    @api.parameters(parameters.PatchAnnotationDetailsParameters())
    @api.response(schemas.DetailedAnnotationSchema())
    @api.response(code=HTTPStatus.CONFLICT)
    def patch(self, args, annotation):
        """
        Patch Annotation details by ID.
        """
        from app.extensions.elapsed_time import ElapsedTime

        timer = ElapsedTime()

        context = api.commit_or_abort(
            db.session, default_error_message='Failed to update Annotation details.'
        )
        with context:
            parameters.PatchAnnotationDetailsParameters.perform_patch(args, annotation)
            db.session.merge(annotation)
            AuditLog.patch_object(log, annotation, args, duration=timer.elapsed())

        return annotation

    @api.permission_required(
        permissions.ObjectAccessPermission,
        kwargs_on_request=lambda kwargs: {
            'obj': kwargs['annotation'],
            'action': AccessOperation.DELETE,
        },
    )
    @api.login_required(oauth_scopes=['annotations:write'])
    @api.response(code=HTTPStatus.CONFLICT)
    @api.response(code=HTTPStatus.NO_CONTENT)
    def delete(self, annotation):
        """
        Delete an Annotation by ID.
        """
        AuditLog.delete_object(log, annotation)
        annotation.delete()
        return None


@api.route('/debug/<uuid:annotation_guid>')
@api.login_required(oauth_scopes=['annotations:read'])
@api.response(
    code=HTTPStatus.NOT_FOUND,
    description='Annotation not found.',
)
@api.resolve_object_by_model(ScoutAnnotation, 'annotation')
class AnnotationDebugByID(Resource):
    """
    Jobs for a specific Annotation.
    """

    @api.permission_required(
        permissions.ObjectAccessPermission,
        kwargs_on_request=lambda kwargs: {
            'obj': kwargs['annotation'],
            'action': AccessOperation.READ_DEBUG,
        },
    )
    def get(self, annotation):
        """
        Get Annotation debug details by ID.
        """
        return annotation.get_debug_json()
