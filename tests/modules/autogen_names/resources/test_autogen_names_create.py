# -*- coding: utf-8 -*-
# pylint: disable=missing-docstring

import pytest

import tests.modules.autogen_names.resources.utils as auto_name_utils
from tests.utils import module_unavailable


@pytest.mark.skipif(
    module_unavailable('autogenerated_names'),
    reason='Autogenerated names module disabled',
)
def test_create_autogenerated_name(
    flask_app_client,
    researcher_1,
    admin_user,
    researcher_2,
    user_manager_user,
    db,
    request,
    test_root,
):

    import uuid

    import tests.modules.individuals.resources.utils as individual_utils

    request.addfinalizer(lambda: auto_name_utils.clear_autogen(flask_app_client))
    individual1_uuids = individual_utils.create_individual_and_sighting(
        flask_app_client,
        researcher_1,
        request,
        test_root,
    )
    individual1_id = individual1_uuids['individual']
    individual1_data = individual_utils.read_individual(  # NOQA
        flask_app_client, researcher_1, individual1_id
    ).json
    auto_name_utils.read_all_autogen_names(flask_app_client, admin_user)
    auto_name_utils.read_all_autogen_names(flask_app_client, researcher_1)
    data = {
        str(uuid.uuid4()): {
            'prefix': 'woo',
            'type': 'auto_species',
            'enabled': True,
            'reference_guid': individual1_data['taxonomy'],
        }
    }
    auto_name_utils.create_autogen_name(flask_app_client, admin_user, data)

    # create another one the same, should fail
    new_data = {str(uuid.uuid4()): {'prefix': 'woo', 'type': 'auto_species'}}
    error = 'All autogenerated names need type, prefix, and reference_guid'
    auto_name_utils.create_autogen_name(
        flask_app_client, admin_user, new_data, 400, error
    )

    names = auto_name_utils.read_all_autogen_names(flask_app_client, admin_user)
    spec_woos = [
        names[name_guid]
        for name_guid in names
        if names[name_guid]['type'] == 'auto_species'
        and names[name_guid]['prefix'] == 'woo'
    ]
    assert len(spec_woos) == 1
    name = spec_woos[0]
    assert name['type'] == 'auto_species'
    assert name['prefix'] == 'woo'

    individual2_uuids = individual_utils.create_individual_and_sighting(
        flask_app_client,
        researcher_1,
        request,
        test_root,
    )
    individual2_id = individual2_uuids['individual']  # NOQA
    individual2_data = individual_utils.read_individual(  # NOQA
        flask_app_client, researcher_1, individual1_id
    ).json


@pytest.mark.skipif(
    module_unavailable('autogenerated_names'),
    reason='Autogenerated names module disabled',
)
def test_create_individual(
    flask_app_client,
    researcher_1,
    admin_user,
    researcher_2,
    user_manager_user,
    db,
    request,
    test_root,
):

    import uuid

    import tests.modules.individuals.resources.utils as individual_utils
    import tests.modules.site_settings.resources.utils as setting_utils
    from app.modules.autogenerated_names.models import (
        AutogeneratedName,
        AutogeneratedNameType,
    )
    from app.modules.individuals.models import Individual

    request.addfinalizer(lambda: auto_name_utils.clear_autogen(flask_app_client))
    individual_uuids = individual_utils.create_individual_and_sighting(
        flask_app_client,
        researcher_1,
        request,
        test_root,
    )
    individual_id = individual_uuids['individual']
    individual_data = individual_utils.read_individual(  # NOQA
        flask_app_client, researcher_1, individual_id
    ).json
    assert len(individual_data['names']) == 0
    individual = Individual.query.get(individual_id)
    assert individual
    assert len(individual.names) == 0
    tx1_guid = individual_data['taxonomy']

    agn_prefix = 'FOO'
    agn_guid = str(uuid.uuid4())
    agn_guid2 = str(uuid.uuid4())
    data = {
        agn_guid: {
            'prefix': agn_prefix,
            'type': 'auto_species',
            'enabled': True,
            'reference_guid': tx1_guid,
        },
        agn_guid2: {
            'prefix': agn_prefix,
            'type': 'auto_species',
            'enabled': True,
            'reference_guid': tx1_guid,
        },
    }
    # should be disallowed due to duplicate reference_guid above
    rtn = auto_name_utils.create_autogen_name(
        flask_app_client, admin_user, data, expected_status_code=400
    )
    assert 'appears in both' in rtn.json['message']

    # now test missing type
    del data[agn_guid2]
    del data[agn_guid]['type']
    rtn = auto_name_utils.create_autogen_name(
        flask_app_client, admin_user, data, expected_status_code=400
    )
    assert 'All autogenerated names need' in rtn.json['message']

    # now bad type
    data[agn_guid]['type'] = 'fubarrrrr'
    rtn = auto_name_utils.create_autogen_name(
        flask_app_client, admin_user, data, expected_status_code=400
    )
    assert 'not supported' in rtn.json['message']

    # now this should work
    data[agn_guid]['type'] = 'auto_species'
    auto_name_utils.create_autogen_name(flask_app_client, admin_user, data)

    agns = auto_name_utils.read_all_autogen_names(flask_app_client, admin_user)
    assert agn_guid in agns

    # above should have autopopulated names for indivs
    assert len(individual.names) == 1
    assert individual.names[0].context == f'autogen-{agn_guid}'
    assert individual.names[0].value == '001'
    assert individual.names[0].value_resolved == f'{agn_prefix}-001'

    # check the counter
    agn = AutogeneratedName.query.get(agn_guid)
    assert agn
    n = agn.get_next()
    assert n == '002'
    n = agn.get_next()
    assert n == '003'
    n = agn.get_next()
    assert n == '004'

    # set up a second taxonomy. first we fail tho do to enabled=False
    agn2_prefix = 'BARR'
    vals = [
        {
            'id': tx1_guid,
            'commonNames': ['Example'],
            'scientificName': 'Exempli gratia',
            'itisTsn': -1234,
            'autogeneratedName': {
                'guid': agn_guid,
                'prefix': agn_prefix,
                'type': 'auto_species',
                'enabled': True,
            },
        },
        {
            'commonNames': ['Example'],
            'scientificName': 'Exempli gratia deux',
            'itisTsn': -1235,
            'autogeneratedName': {
                'prefix': agn2_prefix,
                'type': 'auto_species',
                'enabled': False,
            },
        },
    ]
    rtn = setting_utils.modify_main_settings(
        flask_app_client,
        admin_user,
        vals,
        'site.species',
        expected_status_code=400,
    )
    assert 'Autogen names for all taxonomies' in rtn.json['message']
    # fix that enabled, now it should work -- which should update the AGNs accordingly (so we have 2)
    vals[1]['autogeneratedName']['enabled'] = True
    rtn = setting_utils.modify_main_settings(
        flask_app_client,
        admin_user,
        vals,
        'site.species',
    )
    assert len(rtn.json['value']) == 2
    tx2_guid = rtn.json['value'][1]['id']
    # see if AGN objects match site-settings
    agns = AutogeneratedName.query.all()
    assert len(agns) == 2
    assert str(agns[0].reference_guid) == tx1_guid
    assert str(agns[1].reference_guid) == tx2_guid

    # now we make sure indiv taxonomy/names are cool still
    assert str(individual.get_taxonomy_guid()) == tx1_guid
    assert len(individual.names) == 1
    assert individual.names[0].autogenerated_guid == str(agns[0].guid)
    old_name = individual.names[0].value_resolved
    # update taxonomy and see if autogenerated names end up correct
    individual.taxonomy_guid = tx2_guid
    individual.update_autogen_names(admin_user, AutogeneratedNameType.auto_species.value)
    assert len(individual.names) == 1
    assert individual.names[0].autogenerated_guid == str(
        agns[1].guid
    )  # should come from 2nd agns
    assert old_name != individual.names[0].value_resolved  # should be different

    # try changing prefix of new/second AGN
    agns = AutogeneratedName.query.all()  # need guid
    vals[1]['autogeneratedName']['guid'] = str(agns[1].guid)
    vals[1]['autogeneratedName']['prefix'] = 'BOO'
    vals[1]['id'] = tx2_guid
    rtn = setting_utils.modify_main_settings(
        flask_app_client,
        admin_user,
        vals,
        'site.species',
    )
    agns = AutogeneratedName.query.all()
    assert agns[1].prefix == 'BOO'
    individual = Individual.query.get(individual_id)
    assert individual.names[0].value_resolved == 'BOO-001'


def test_config(
    flask_app_client,
    researcher_1,
    admin_user,
    researcher_2,
    user_manager_user,
    db,
    request,
    test_root,
):

    import uuid

    import tests.modules.individuals.resources.utils as individual_utils
    import tests.modules.site_settings.resources.utils as setting_utils
    from app.modules.autogenerated_names.models import AutogeneratedName

    request.addfinalizer(lambda: auto_name_utils.clear_autogen(flask_app_client))
    individual1_uuids = individual_utils.create_individual_and_sighting(
        flask_app_client,
        researcher_1,
        request,
        test_root,
    )
    individual1_id = individual1_uuids['individual']
    individual1_data = individual_utils.read_individual(  # NOQA
        flask_app_client, researcher_1, individual1_id
    ).json

    tx1_guid = individual1_data['taxonomy']
    agn_prefix = 'BAR'
    agn_guid = str(uuid.uuid4())
    data = {
        agn_guid: {
            'prefix': agn_prefix,
            'type': 'auto_species',
            'enabled': True,
            'next_value': 999,
            'reference_guid': tx1_guid,
        },
    }
    # fails due to next_value (currently) being forbidden
    rtn = auto_name_utils.create_autogen_name(
        flask_app_client,
        admin_user,
        data,
        expected_status_code=400,
    )
    assert 'next_value currently forbidden' in rtn.json['message']
    del data[agn_guid]['next_value']
    # this creates an autoname for tx1_guid
    auto_name_utils.create_autogen_name(
        flask_app_client,
        admin_user,
        data,
    )
    agns = auto_name_utils.read_all_autogen_names(flask_app_client, admin_user)
    # now lets add a new taxonomy to the mix
    #  note: this does nothing with AGN so it should reset above AGN to enabled=False
    assert agn_guid in agns
    assert agns[agn_guid]['enabled']
    vals = [
        {
            'id': tx1_guid,
            'commonNames': ['Example'],
            'scientificName': 'Exempli gratia',
            'itisTsn': -1234,
        },
        {
            'commonNames': ['Example'],
            'scientificName': 'Exempli gratia deux',
            'itisTsn': -1235,
        },
    ]
    rtn = setting_utils.modify_main_settings(
        flask_app_client,
        admin_user,
        vals,
        'site.species',
    )
    assert len(rtn.json['value']) == 2
    tx2_guid = rtn.json['value'][1]['id']
    # test that agn is now disabled (but still exists)
    agns = auto_name_utils.read_all_autogen_names(flask_app_client, admin_user)
    assert agn_guid in agns
    assert not agns[agn_guid]['enabled']

    # now lets test autogen based on 2 taxonomies
    agn2_guid = str(uuid.uuid4())
    data = {
        agn_guid: {
            'prefix': agn_prefix,
            'type': 'auto_species',
            'enabled': True,
            'reference_guid': tx1_guid,
        },
        agn2_guid: {
            'prefix': agn_prefix,
            'type': 'auto_species',
            'enabled': True,
            'reference_guid': tx2_guid,
        },
    }
    # fails due to duplicate prefix (for same type)
    rtn = auto_name_utils.create_autogen_name(
        flask_app_client,
        admin_user,
        data,
        expected_status_code=400,
    )
    assert f'Prefix {agn_prefix} cannot be used more than once' in rtn.json['message']
    agn2_prefix = 'I AM WAY TOO LONG'
    data[agn2_guid]['prefix'] = agn2_prefix
    rtn = auto_name_utils.create_autogen_name(
        flask_app_client,
        admin_user,
        data,
        expected_status_code=400,
    )
    assert 'must be between' in rtn.json['message']
    agn2_prefix = 'FUBAR'
    data[agn2_guid]['prefix'] = agn2_prefix
    rtn = auto_name_utils.create_autogen_name(
        flask_app_client,
        admin_user,
        data,
    )
    # check site-settings value
    agns = auto_name_utils.read_all_autogen_names(flask_app_client, admin_user)
    assert len(agns) == 2
    assert agn_guid in agns
    assert agn2_guid in agns
    # now check actual objects/table
    agn_objs = AutogeneratedName.query.all()
    assert len(agn_objs) == 2
    assert str(agn_objs[0].guid) == agn_guid
    assert agn_objs[0].enabled
    assert str(agn_objs[0].reference_guid) == tx1_guid
    assert agn_objs[0].prefix == agn_prefix
    assert str(agn_objs[1].guid) == agn2_guid
    assert agn_objs[1].enabled
    assert str(agn_objs[1].reference_guid) == tx2_guid
    assert agn_objs[1].prefix == agn2_prefix
