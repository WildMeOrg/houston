# -*- coding: utf-8 -*-
"""
Autogeneratednames database models
--------------------
"""

import enum
import logging
import uuid

from app.extensions import HoustonModel, db
from app.utils import HoustonException

log = logging.getLogger(__name__)  # pylint: disable=invalid-name

AUTOGEN_NAME_PREFIX_MIN_LENGTH = 3
AUTOGEN_NAME_PREFIX_MAX_LENGTH = 5
AUTOGEN_NAME_CONTEXT_PREFIX = 'auto'


class AutogeneratedNameType(str, enum.Enum):
    auto_species = 'auto_species'
    auto_region = 'auto_region'
    auto_project = 'auto_project'
    auto_organization = 'auto_organization'


class AutogeneratedName(db.Model, HoustonModel):
    """
    AutogeneratedNames database model.
    """

    guid = db.Column(
        db.GUID, default=uuid.uuid4, primary_key=True
    )  # pylint: disable=invalid-name

    type = db.Column(
        db.Enum(AutogeneratedNameType),
        default=AutogeneratedNameType.auto_species,
        nullable=False,
        index=True,
    )
    prefix = db.Column(db.String(), index=True, nullable=False)
    # taxonomy guid for species
    # TODO should this become nullable=False ?
    reference_guid = db.Column(db.GUID, index=True, nullable=False, unique=True)
    next_value = db.Column(db.Integer, default=1)
    enabled = db.Column(db.Boolean, nullable=False, default=True)

    def __repr__(self):
        return (
            '<{class_name}('
            'guid={self.guid}, '
            'type={self.type}, '
            'enabled={self.enabled}, '
            'prefix={self.prefix}, '
            'reference_guid={self.reference_guid}'
            ')>'.format(class_name=self.__class__.__name__, self=self)
        )

    @classmethod
    def type_enabled(cls, type):
        if not type or type not in AutogeneratedNameType.__members__.values():
            return False
        # TODO/FIXME make this look at settings etc!!
        return True

    @property
    def context(self):
        return f'autogen-{self.guid}'

    def get_next(self):
        with db.session.begin():
            # keep read/modify/write all within the single db.session to make it atomic WRT the DB
            next_val = str(self.next_value).zfill(3)
            self.next_value += 1
            db.session.merge(self)
        return str(next_val)

    # use on newly-created or newly-enabled agn
    def populate_all_individuals(self, user):
        from app.modules.individuals.models import Individual

        indivs = Individual.query.all()
        for indiv in indivs:
            if not indiv.has_name_context(self.context):
                log.debug(f'populating {self} on {indiv} with user {user}')
                indiv.update_autogen_name(user, self)

    # takes a Name and returns human-facing value
    @classmethod
    def resolve_value(cls, name):
        if not name.context.startswith('autogen-'):
            return name.value  # lets be kind
        agn = AutogeneratedName.query.get(name.context[8:])
        if not agn:
            log.warning(f'no matching AutogeneratedName for {name}')
            return None
        return f'{agn.prefix}-{name.value}'

    # skip_taxonomy_check is specifically for site.species setting which needs to also set this (but taxonomies wont exist yet)
    @classmethod
    def validate_names(cls, new_autogen_names, skip_taxonomy_check=False):
        from app.modules.site_settings.models import Taxonomy

        assert isinstance(new_autogen_names, dict)
        enabled_taxonomies = []
        all_taxonomies = []
        ref = {}
        for new_agn_guid in new_autogen_names:
            new_agn = new_autogen_names[new_agn_guid]
            if (
                'type' not in new_agn
                or 'prefix' not in new_agn
                or 'enabled' not in new_agn
                or 'reference_guid' not in new_agn
            ):
                raise HoustonException(
                    log, 'All autogenerated names need type, prefix, and reference_guid'
                )
            if 'next_value' in new_agn:
                raise HoustonException(
                    log,
                    'Changing next_value currently forbidden',
                )
            if new_agn['reference_guid'] in ref:
                raise HoustonException(
                    log,
                    f"Reference guid {new_agn['reference_guid']} appears in both {new_agn_guid} and {ref[new_agn['reference_guid']]}",
                )
            ref[new_agn['reference_guid']] = new_agn_guid
            prefix_len = len(new_agn['prefix'])
            if (
                prefix_len < AUTOGEN_NAME_PREFIX_MIN_LENGTH
                or prefix_len > AUTOGEN_NAME_PREFIX_MAX_LENGTH
            ):
                raise HoustonException(
                    log,
                    f'Prefix {new_agn["prefix"]} invalid, must be between {AUTOGEN_NAME_PREFIX_MIN_LENGTH} and '
                    f'{AUTOGEN_NAME_PREFIX_MAX_LENGTH} characters long',
                )
            if new_agn['type'] not in AutogeneratedNameType.__members__.values():
                raise HoustonException(log, f"Type {new_agn['type']} not supported")

            # test taxonomy value
            if new_agn['type'] == AutogeneratedNameType.auto_species.value:
                try:
                    skip_taxonomy_check or Taxonomy(new_agn['reference_guid'])
                except ValueError:
                    raise HoustonException(
                        log,
                        f"Invalid taxonomy guid {new_agn['reference_guid']}",
                    )
                all_taxonomies.append(new_agn['reference_guid'])
                if new_agn['enabled']:
                    enabled_taxonomies.append(new_agn['reference_guid'])

        # we need to have all or nothing enabled for taxonomies
        if enabled_taxonomies:
            # this means passed in some enabled=T and some enabled=F
            if len(enabled_taxonomies) != len(all_taxonomies):
                raise HoustonException(
                    log,
                    f'You must set/enable/disable Autogen names for all taxonomies; missing {all_taxonomies - enabled_taxonomies}',
                )
            txs = Taxonomy.get_configuration_value() or []
            missing = [t['id'] for t in txs if t['id'] not in enabled_taxonomies]
            if not skip_taxonomy_check and missing:
                raise HoustonException(
                    log,
                    f"You must set/enable/disable Autogen names for all taxonomies; missing {', '.join(missing)}",
                )

        existing_names = AutogeneratedName.query.all()
        # validate all present, cannot remove any type/prefix combinations
        for agn in existing_names:
            if str(agn.guid) not in new_autogen_names:
                raise HoustonException(
                    log,
                    f'Cannot remove existing autogen name type:{agn.type} prefix:{agn.prefix}',
                )
            if str(agn.reference_guid) in ref and ref[str(agn.reference_guid)] != str(
                agn.guid
            ):
                raise HoustonException(
                    log,
                    f'Reference guid {agn.reference_guid} appears in both {agn.guid} and {ref[agn.reference_guid]}',
                )
            new_agn = new_autogen_names[str(agn.guid)]
            new_matches = []
            for new_agn_guid in new_autogen_names:
                new_agn_match = new_autogen_names[new_agn_guid]
                if (
                    agn.type == new_agn_match['type']
                    and agn.prefix == new_agn_match['prefix']
                ):
                    new_matches.append(new_agn_guid)
            if len(new_matches) > 1:
                raise HoustonException(
                    log,
                    f'Cannot create an additional autogenerated name for type:{agn.type}, prefix:{agn.prefix}',
                )
            if new_agn['type'] != agn.type.value:
                raise HoustonException(
                    log,
                    f'Cannot change type of existing autogen name guid {agn.guid}, type:{agn.type}',
                )
            # we *can* allow change of prefix now, as name is constructed dynamically
            # if new_agn['prefix'] != agn.prefix:
            # if (
            #    'reference_guid' in new_agn
            #    and new_agn['reference_guid'] != agn.reference_guid
            # ):
            if 'next_value' in new_agn and new_agn['next_value'] < agn.next_value:
                raise HoustonException(
                    log,
                    f'Cannot lower start value of existing autogen name guid {agn.guid}, next_value:{agn.next_value}',
                )

    # this assumes validate_names() above already caught forbidden data
    @classmethod
    def set_names_as_rest(cls, new_autogen_names):
        from flask_login import current_user

        for new_agn_guid in new_autogen_names:
            new_agn = new_autogen_names[new_agn_guid]
            existing_agn = AutogeneratedName.query.get(new_agn_guid)
            if existing_agn:
                re_enabled = not existing_agn.enabled and new_agn['enabled']
                with db.session.begin(subtransactions=True):
                    # existing_agn.next_value = new_agn.get('next_value', 1)  # disabled
                    existing_agn.prefix = new_agn['prefix']
                    existing_agn.enabled = new_agn['enabled']
                    db.session.merge(existing_agn)
                if re_enabled:
                    log.debug(
                        f'auto-populating due to existing AGN re-enabled with {new_agn}'
                    )
                    existing_agn.populate_all_individuals(current_user)
            else:
                with db.session.begin(subtransactions=True):
                    reference_guid = (
                        uuid.UUID(new_agn['reference_guid'])
                        if 'reference_guid' in new_agn
                        else None
                    )
                    # next_value = new_agn['next_value'] if 'next_value' in new_agn else 1
                    autogenerated_name = AutogeneratedName(
                        guid=uuid.UUID(new_agn_guid),
                        type=new_agn['type'],
                        prefix=new_agn['prefix'],
                        enabled=new_agn['enabled'],
                        reference_guid=reference_guid,
                        # next_value=next_value,  # disabled
                    )
                    db.session.add(autogenerated_name)

                autogenerated_name.populate_all_individuals(current_user)
                import app.extensions.logging as AuditLog  # NOQA

                AuditLog.user_create_object(log, autogenerated_name)

    @classmethod
    def get_rest_response(cls):
        ret_val = {}
        all_agn = AutogeneratedName.query.all()
        for agn in all_agn:
            ret_val[str(agn.guid)] = {
                'type': agn.type,
                'prefix': agn.prefix,
                'reference_guid': agn.reference_guid,
                'next_value': agn.next_value,
            }
        return ret_val
