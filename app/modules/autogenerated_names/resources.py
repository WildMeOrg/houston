# -*- coding: utf-8 -*-
# pylint: disable=bad-continuation
"""
RESTful API AutogeneratedNames resources
--------------------------
"""

import logging

from flask import request
from flask_restx._http import HTTPStatus

from app.extensions import db
from app.extensions.api import Namespace, abort
from app.modules.users import permissions
from app.modules.users.permissions.types import AccessOperation
from flask_restx_patched import Resource

from . import parameters, schemas
from .models import (
    AUTOGEN_NAME_PREFIX_MAX_LENGTH,
    AUTOGEN_NAME_PREFIX_MIN_LENGTH,
    AutogeneratedName,
    AutogeneratedNameType,
)

log = logging.getLogger(__name__)  # pylint: disable=invalid-name
api = Namespace(
    'autogenerated_names', description='Autogenerated_Names'
)  # pylint: disable=invalid-name


@api.route('/')
@api.login_required(oauth_scopes=['AutogeneratedNames:read'])
class AutogeneratedNames(Resource):
    """
    Manipulations with AutogeneratedNames.
    """

    @api.permission_required(
        permissions.ModuleAccessPermission,
        kwargs_on_request=lambda kwargs: {
            'module': AutogeneratedName,
            'action': AccessOperation.READ,
        },
    )
    @api.response(schemas.DetailedAutogeneratedNameSchema(many=True))
    @api.paginate()
    def get(self, args):
        """
        List of AutogeneratedName.

        Returns a list of AutogeneratedName starting from ``offset`` limited by ``limit``
        parameter.
        """
        return AutogeneratedName.query_search(args=args)

    @api.permission_required(
        permissions.ModuleAccessPermission,
        kwargs_on_request=lambda kwargs: {
            'module': AutogeneratedName,
            'action': AccessOperation.WRITE,
        },
    )
    @api.login_required(oauth_scopes=['AutogeneratedNames:write'])
    @api.parameters(parameters.CreateAutogeneratedNameParameters())
    @api.response(schemas.DetailedAutogeneratedNameSchema())
    @api.response(code=HTTPStatus.CONFLICT)
    def post(self, args):
        """
        Create a new instance of autogenerated_name.
        """

        import app.extensions.logging as AuditLog  # NOQA
        from app.extensions.elapsed_time import ElapsedTime

        timer = ElapsedTime()

        request_in = {}
        import json

        try:
            request_in_ = json.loads(request.data)
            request_in.update(request_in_)
        except Exception:
            pass

        context = api.commit_or_abort(
            db.session, default_error_message='Failed to create a new AutogeneratedName'
        )

        existing = AutogeneratedName.query.filter_by(
            prefix=request_in['prefix'], type=request_in['type']
        ).first()
        if existing:
            error = f'Autogenerated Name of type:{request_in["type"]} with prefix:{request_in["prefix"]} already exists'
            AuditLog.frontend_fault(log, error)
            abort(code=HTTPStatus.BAD_REQUEST, message=error)

        # return autogenerated_name
        if (
            request_in['type'] in AutogeneratedNameType.__members__
            and AUTOGEN_NAME_PREFIX_MIN_LENGTH
            <= len(request_in['prefix'])
            <= AUTOGEN_NAME_PREFIX_MAX_LENGTH
        ):

            with context:
                autogenerated_name = AutogeneratedName(
                    type=request_in['type'],
                    prefix=request_in['prefix'],
                    reference_guid=request_in['reference_guid']
                    if 'reference_guid' in request_in
                    else None,
                    next_value=request_in['start_value']
                    if 'start_value' in request_in
                    else 0,
                )

                db.session.add(autogenerated_name)

                AuditLog.user_create_object(
                    log, autogenerated_name, duration=timer.elapsed()
                )
        else:
            AuditLog.frontend_fault(log, 'Invalid params')
            abort(code=HTTPStatus.BAD_REQUEST, message='Invalid params')
        return autogenerated_name


@api.route('/<uuid:autogenerated_name_guid>')
@api.login_required(oauth_scopes=['AutogeneratedNames:read'])
@api.response(
    code=HTTPStatus.NOT_FOUND,
    description='AutogeneratedName not found.',
)
@api.resolve_object_by_model(AutogeneratedName, 'autogenerated_name')
class AutogeneratedNameByID(Resource):
    """
    Manipulations with a specific AutogeneratedName.
    """

    @api.permission_required(
        permissions.ObjectAccessPermission,
        kwargs_on_request=lambda kwargs: {
            'obj': kwargs['autogenerated_name'],
            'action': AccessOperation.READ,
        },
    )
    @api.response(schemas.DetailedAutogeneratedNameSchema())
    def get(self, autogenerated_name):
        """
        Get AutogeneratedName details by ID.
        """
        return autogenerated_name

    # @api.permission_required(
    #     permissions.ObjectAccessPermission,
    #     kwargs_on_request=lambda kwargs: {
    #         'obj': kwargs['AutogeneratedName'],
    #         'action': AccessOperation.WRITE,
    #     },
    # )
    # @api.login_required(oauth_scopes=['AutogeneratedNames:write'])
    # @api.parameters(parameters.PatchAutogeneratedNameDetailsParameters())
    # @api.response(schemas.DetailedAutogeneratedNameSchema())
    # @api.response(code=HTTPStatus.CONFLICT)
    # def patch(self, args, autogenerated_name):
    #     """
    #     Patch AutogeneratedName details by ID.
    #     """
    #     context = api.commit_or_abort(
    #         db.session,
    #         default_error_message="Failed to update AutogeneratedName details."
    #     )
    #     with context:
    #         parameters.PatchAutogeneratedNameDetailsParameters.perform_patch(args, obj=autogenerated_name)
    #         db.session.merge(autogenerated_name)
    #     return autogenerated_name
